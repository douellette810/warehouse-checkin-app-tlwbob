
/**
 * Warehouse Check-In API Server with Authentication
 * 
 * This is a complete Node.js + Express server template for your Warehouse Check-In app.
 * It provides REST API endpoints that connect to your SQL Server database.
 * 
 * SETUP INSTRUCTIONS:
 * 1. Copy this file to your backend project directory as 'server.js'
 * 2. Install dependencies: npm install express mssql cors dotenv
 * 3. Create a .env file with your database credentials (see .env.template)
 * 4. Run the SQL script in AUTHENTICATION_SETUP.md to create the users table
 * 5. Run: npm start
 */

const express = require('express');
const cors = require('cors');
const sql = require('mssql');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors()); // Enable CORS for React Native app
app.use(express.json()); // Parse JSON request bodies
app.use(express.urlencoded({ extended: true })); // Parse URL-encoded bodies

// SQL Server Configuration - Using SQL Authentication
const dbConfig = {
  server: process.env.DB_SERVER || 'CRSERV\\SQLEXPRESS',
  user: process.env.DB_USER || 'sql',
  password: process.env.DB_PASSWORD || 'W1@3!-j/R',
  database: process.env.DB_DATABASE || 'WarehouseCheckIn',
  options: {
    encrypt: process.env.DB_ENCRYPT === 'true',
    trustServerCertificate: process.env.DB_TRUST_SERVER_CERTIFICATE !== 'false',
    enableArithAbort: true,
  },
  pool: {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  }
};

// Database connection pool
let pool = null;

// Initialize database connection
async function initDatabase() {
  try {
    console.log('ğŸ”„ Connecting to SQL Server...');
    console.log(`   Server: ${dbConfig.server}`);
    console.log(`   Database: ${dbConfig.database}`);
    console.log(`   User: ${dbConfig.user}`);
    console.log('   Auth Mode: SQL Server Authentication');
    
    pool = await sql.connect(dbConfig);
    
    console.log('âœ… Connected to SQL Server');
  } catch (err) {
    console.error('âŒ Database connection error:', err);
    console.error('');
    console.error('Troubleshooting tips:');
    console.error('1. Verify SQL Server is running: Get-Service MSSQL*');
    console.error('2. Check SQL Server Configuration Manager:');
    console.error('   - Enable TCP/IP protocol');
    console.error('   - Restart SQL Server service');
    console.error('3. Verify SQL Server Authentication is enabled:');
    console.error('   - Open SQL Server Management Studio');
    console.error('   - Right-click server > Properties > Security');
    console.error('   - Select "SQL Server and Windows Authentication mode"');
    console.error('   - Restart SQL Server service');
    console.error('4. Verify the SQL user has proper permissions:');
    console.error('   - User should have db_datareader and db_datawriter roles');
    console.error('   - Check user mapping in SQL Server Management Studio');
    console.error('');
    process.exit(1);
  }
}

// Error handling middleware
function handleError(res, error, message = 'An error occurred') {
  console.error(message, error);
  res.status(500).json({
    success: false,
    error: message,
    details: error.message
  });
}

// ============================================================================
// HEALTH CHECK ENDPOINT
// ============================================================================

app.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'Warehouse API is running',
    timestamp: new Date().toISOString(),
    database: pool ? 'connected' : 'disconnected',
    authMode: 'SQL Server Authentication'
  });
});

// ============================================================================
// AUTHENTICATION ENDPOINTS
// ============================================================================

// POST login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        error: 'Email and password are required'
      });
    }
    
    console.log('Login attempt for:', email);
    
    const result = await pool.request()
      .input('email', sql.NVarChar, email)
      .query('SELECT * FROM users WHERE email = @email');
    
    if (result.recordset.length === 0) {
      console.log('User not found:', email);
      return res.status(401).json({
        success: false,
        error: 'Invalid email or password'
      });
    }
    
    const user = result.recordset[0];
    
    // Check password (in production, use bcrypt.compare)
    if (user.password_hash !== password) {
      console.log('Invalid password for:', email);
      return res.status(401).json({
        success: false,
        error: 'Invalid email or password'
      });
    }
    
    console.log('Login successful for:', email);
    
    // Return user data (excluding password)
    const userData = {
      id: user.id,
      name: user.name,
      email: user.email,
      employee_id: user.employee_id,
      created_at: user.created_at
    };
    
    res.json({
      success: true,
      data: userData,
      message: 'Login successful'
    });
  } catch (error) {
    handleError(res, error, 'Error during login');
  }
});

// POST change password
app.post('/api/auth/change-password', async (req, res) => {
  try {
    const { userId, currentPassword, newPassword } = req.body;
    
    if (!userId || !currentPassword || !newPassword) {
      return res.status(400).json({
        success: false,
        error: 'All fields are required'
      });
    }
    
    console.log('Password change attempt for user:', userId);
    
    // Get current user
    const userResult = await pool.request()
      .input('id', sql.UniqueIdentifier, userId)
      .query('SELECT * FROM users WHERE id = @id');
    
    if (userResult.recordset.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    const user = userResult.recordset[0];
    
    // Verify current password (in production, use bcrypt.compare)
    if (user.password_hash !== currentPassword) {
      console.log('Current password incorrect for user:', userId);
      return res.status(401).json({
        success: false,
        error: 'Current password is incorrect'
      });
    }
    
    // Update password (in production, use bcrypt.hash)
    await pool.request()
      .input('id', sql.UniqueIdentifier, userId)
      .input('newPassword', sql.NVarChar, newPassword)
      .query('UPDATE users SET password_hash = @newPassword WHERE id = @id');
    
    console.log('Password changed successfully for user:', userId);
    
    res.json({
      success: true,
      message: 'Password changed successfully'
    });
  } catch (error) {
    handleError(res, error, 'Error changing password');
  }
});

// POST update employee preference
app.post('/api/auth/update-employee-preference', async (req, res) => {
  try {
    const { userId, employeeId } = req.body;
    
    if (!userId) {
      return res.status(400).json({
        success: false,
        error: 'User ID is required'
      });
    }
    
    console.log('Updating employee preference for user:', userId, 'to employee:', employeeId);
    
    // Update user's employee preference
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, userId)
      .input('employeeId', employeeId ? sql.UniqueIdentifier : sql.NVarChar, employeeId || null)
      .query(`
        UPDATE users SET employee_id = @employeeId WHERE id = @id;
        SELECT id, name, email, employee_id, created_at FROM users WHERE id = @id
      `);
    
    if (result.recordset.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    console.log('Employee preference updated successfully');
    
    res.json({
      success: true,
      data: result.recordset[0],
      message: 'Employee preference updated successfully'
    });
  } catch (error) {
    handleError(res, error, 'Error updating employee preference');
  }
});

// ============================================================================
// EMPLOYEES ENDPOINTS
// ============================================================================

// GET all employees
app.get('/api/employees', async (req, res) => {
  try {
    const result = await pool.request()
      .query('SELECT * FROM employees ORDER BY created_at DESC');
    
    res.json({
      success: true,
      data: result.recordset
    });
  } catch (error) {
    handleError(res, error, 'Error fetching employees');
  }
});

// GET single employee
app.get('/api/employees/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .query('SELECT * FROM employees WHERE id = @id');
    
    if (result.recordset.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Employee not found'
      });
    }
    
    res.json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error fetching employee');
  }
});

// POST create employee
app.post('/api/employees', async (req, res) => {
  try {
    const { name } = req.body;
    
    if (!name) {
      return res.status(400).json({
        success: false,
        error: 'Name is required'
      });
    }
    
    const result = await pool.request()
      .input('name', sql.NVarChar, name)
      .query('INSERT INTO employees (name) OUTPUT INSERTED.* VALUES (@name)');
    
    res.status(201).json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error creating employee');
  }
});

// PUT update employee
app.put('/api/employees/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name } = req.body;
    
    if (!name) {
      return res.status(400).json({
        success: false,
        error: 'Name is required'
      });
    }
    
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .input('name', sql.NVarChar, name)
      .query('UPDATE employees SET name = @name WHERE id = @id; SELECT * FROM employees WHERE id = @id');
    
    if (result.recordset.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Employee not found'
      });
    }
    
    res.json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error updating employee');
  }
});

// DELETE employee
app.delete('/api/employees/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .query('DELETE FROM employees WHERE id = @id');
    
    if (result.rowsAffected[0] === 0) {
      return res.status(404).json({
        success: false,
        error: 'Employee not found'
      });
    }
    
    res.json({
      success: true,
      message: 'Employee deleted successfully'
    });
  } catch (error) {
    handleError(res, error, 'Error deleting employee');
  }
});

// ============================================================================
// COMPANIES ENDPOINTS
// ============================================================================

// GET all companies
app.get('/api/companies', async (req, res) => {
  try {
    const result = await pool.request()
      .query('SELECT * FROM companies ORDER BY created_at DESC');
    
    res.json({
      success: true,
      data: result.recordset
    });
  } catch (error) {
    handleError(res, error, 'Error fetching companies');
  }
});

// POST create company
app.post('/api/companies', async (req, res) => {
  try {
    const { name, address, contact_person, email, phone } = req.body;
    
    if (!name || !address || !contact_person || !email || !phone) {
      return res.status(400).json({
        success: false,
        error: 'All fields are required'
      });
    }
    
    const result = await pool.request()
      .input('name', sql.NVarChar, name)
      .input('address', sql.NVarChar, address)
      .input('contact_person', sql.NVarChar, contact_person)
      .input('email', sql.NVarChar, email)
      .input('phone', sql.NVarChar, phone)
      .query(`
        INSERT INTO companies (name, address, contact_person, email, phone)
        OUTPUT INSERTED.*
        VALUES (@name, @address, @contact_person, @email, @phone)
      `);
    
    res.status(201).json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error creating company');
  }
});

// PUT update company
app.put('/api/companies/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, address, contact_person, email, phone } = req.body;
    
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .input('name', sql.NVarChar, name)
      .input('address', sql.NVarChar, address)
      .input('contact_person', sql.NVarChar, contact_person)
      .input('email', sql.NVarChar, email)
      .input('phone', sql.NVarChar, phone)
      .query(`
        UPDATE companies 
        SET name = @name, address = @address, contact_person = @contact_person,
            email = @email, phone = @phone
        WHERE id = @id;
        SELECT * FROM companies WHERE id = @id
      `);
    
    res.json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error updating company');
  }
});

// DELETE company
app.delete('/api/companies/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .query('DELETE FROM companies WHERE id = @id');
    
    res.json({
      success: true,
      message: 'Company deleted successfully'
    });
  } catch (error) {
    handleError(res, error, 'Error deleting company');
  }
});

// ============================================================================
// CATEGORIES ENDPOINTS
// ============================================================================

// GET all categories
app.get('/api/categories', async (req, res) => {
  try {
    const result = await pool.request()
      .query('SELECT * FROM categories ORDER BY created_at DESC');
    
    res.json({
      success: true,
      data: result.recordset
    });
  } catch (error) {
    handleError(res, error, 'Error fetching categories');
  }
});

// POST create category
app.post('/api/categories', async (req, res) => {
  try {
    const { name } = req.body;
    
    const result = await pool.request()
      .input('name', sql.NVarChar, name)
      .query('INSERT INTO categories (name) OUTPUT INSERTED.* VALUES (@name)');
    
    res.status(201).json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error creating category');
  }
});

// PUT update category
app.put('/api/categories/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name } = req.body;
    
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .input('name', sql.NVarChar, name)
      .query('UPDATE categories SET name = @name WHERE id = @id; SELECT * FROM categories WHERE id = @id');
    
    res.json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error updating category');
  }
});

// DELETE category
app.delete('/api/categories/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .query('DELETE FROM categories WHERE id = @id');
    
    res.json({
      success: true,
      message: 'Category deleted successfully'
    });
  } catch (error) {
    handleError(res, error, 'Error deleting category');
  }
});

// ============================================================================
// VALUE SCRAP ENDPOINTS
// ============================================================================

// GET all value scrap
app.get('/api/value-scrap', async (req, res) => {
  try {
    const result = await pool.request()
      .query('SELECT * FROM value_scrap ORDER BY created_at DESC');
    
    res.json({
      success: true,
      data: result.recordset
    });
  } catch (error) {
    handleError(res, error, 'Error fetching value scrap');
  }
});

// POST create value scrap
app.post('/api/value-scrap', async (req, res) => {
  try {
    const { name, measurement } = req.body;
    
    const result = await pool.request()
      .input('name', sql.NVarChar, name)
      .input('measurement', sql.NVarChar, measurement)
      .query('INSERT INTO value_scrap (name, measurement) OUTPUT INSERTED.* VALUES (@name, @measurement)');
    
    res.status(201).json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error creating value scrap');
  }
});

// PUT update value scrap
app.put('/api/value-scrap/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, measurement } = req.body;
    
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .input('name', sql.NVarChar, name)
      .input('measurement', sql.NVarChar, measurement)
      .query('UPDATE value_scrap SET name = @name, measurement = @measurement WHERE id = @id; SELECT * FROM value_scrap WHERE id = @id');
    
    res.json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error updating value scrap');
  }
});

// DELETE value scrap
app.delete('/api/value-scrap/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .query('DELETE FROM value_scrap WHERE id = @id');
    
    res.json({
      success: true,
      message: 'Value scrap deleted successfully'
    });
  } catch (error) {
    handleError(res, error, 'Error deleting value scrap');
  }
});

// ============================================================================
// CHARGE MATERIALS ENDPOINTS
// ============================================================================

// GET all charge materials
app.get('/api/charge-materials', async (req, res) => {
  try {
    const result = await pool.request()
      .query('SELECT * FROM charge_materials ORDER BY created_at DESC');
    
    res.json({
      success: true,
      data: result.recordset
    });
  } catch (error) {
    handleError(res, error, 'Error fetching charge materials');
  }
});

// POST create charge material
app.post('/api/charge-materials', async (req, res) => {
  try {
    const { name, measurement } = req.body;
    
    const result = await pool.request()
      .input('name', sql.NVarChar, name)
      .input('measurement', sql.NVarChar, measurement)
      .query('INSERT INTO charge_materials (name, measurement) OUTPUT INSERTED.* VALUES (@name, @measurement)');
    
    res.status(201).json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error creating charge material');
  }
});

// PUT update charge material
app.put('/api/charge-materials/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { name, measurement } = req.body;
    
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .input('name', sql.NVarChar, name)
      .input('measurement', sql.NVarChar, measurement)
      .query('UPDATE charge_materials SET name = @name, measurement = @measurement WHERE id = @id; SELECT * FROM charge_materials WHERE id = @id');
    
    res.json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error updating charge material');
  }
});

// DELETE charge material
app.delete('/api/charge-materials/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .query('DELETE FROM charge_materials WHERE id = @id');
    
    res.json({
      success: true,
      message: 'Charge material deleted successfully'
    });
  } catch (error) {
    handleError(res, error, 'Error deleting charge material');
  }
});

// ============================================================================
// I-SERIES ENDPOINTS
// ============================================================================

// GET all i-series
app.get('/api/i-series', async (req, res) => {
  try {
    const result = await pool.request()
      .query('SELECT * FROM i_series ORDER BY created_at DESC');
    
    res.json({
      success: true,
      data: result.recordset
    });
  } catch (error) {
    handleError(res, error, 'Error fetching i-series');
  }
});

// POST create i-series
app.post('/api/i-series', async (req, res) => {
  try {
    const { processor_series, processor_generation } = req.body;
    
    const result = await pool.request()
      .input('processor_series', sql.NVarChar, processor_series)
      .input('processor_generation', sql.NVarChar, processor_generation)
      .query('INSERT INTO i_series (processor_series, processor_generation) OUTPUT INSERTED.* VALUES (@processor_series, @processor_generation)');
    
    res.status(201).json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error creating i-series');
  }
});

// PUT update i-series
app.put('/api/i-series/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { processor_series, processor_generation } = req.body;
    
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .input('processor_series', sql.NVarChar, processor_series)
      .input('processor_generation', sql.NVarChar, processor_generation)
      .query('UPDATE i_series SET processor_series = @processor_series, processor_generation = @processor_generation WHERE id = @id; SELECT * FROM i_series WHERE id = @id');
    
    res.json({
      success: true,
      data: result.recordset[0]
    });
  } catch (error) {
    handleError(res, error, 'Error updating i-series');
  }
});

// DELETE i-series
app.delete('/api/i-series/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .query('DELETE FROM i_series WHERE id = @id');
    
    res.json({
      success: true,
      message: 'i-Series deleted successfully'
    });
  } catch (error) {
    handleError(res, error, 'Error deleting i-series');
  }
});

// ============================================================================
// CHECK-INS ENDPOINTS
// ============================================================================

// GET all check-ins
app.get('/api/check-ins', async (req, res) => {
  try {
    const result = await pool.request()
      .query('SELECT * FROM check_ins ORDER BY created_at DESC');
    
    // Parse JSON fields
    const checkIns = result.recordset.map(row => ({
      ...row,
      categories: row.categories ? JSON.parse(row.categories) : [],
      value_scrap: row.value_scrap ? JSON.parse(row.value_scrap) : [],
      charge_materials: row.charge_materials ? JSON.parse(row.charge_materials) : [],
      value_scrap_totals: row.value_scrap_totals ? JSON.parse(row.value_scrap_totals) : [],
      charge_materials_totals: row.charge_materials_totals ? JSON.parse(row.charge_materials_totals) : [],
      i_series_pcs: row.i_series_pcs ? JSON.parse(row.i_series_pcs) : [],
      i_series_laptops: row.i_series_laptops ? JSON.parse(row.i_series_laptops) : [],
    }));
    
    res.json({
      success: true,
      data: checkIns
    });
  } catch (error) {
    handleError(res, error, 'Error fetching check-ins');
  }
});

// GET single check-in
app.get('/api/check-ins/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.request()
      .input('id', sql.UniqueIdentifier, id)
      .query('SELECT * FROM check_ins WHERE id = @id');
    
    if (result.recordset.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'Check-in not found'
      });
    }
    
    const checkIn = result.recordset[0];
    
    // Parse JSON fields
    const parsedCheckIn = {
      ...checkIn,
      categories: checkIn.categories ? JSON.parse(checkIn.categories) : [],
      value_scrap: checkIn.value_scrap ? JSON.parse(checkIn.value_scrap) : [],
      charge_materials: checkIn.charge_materials ? JSON.parse(checkIn.charge_materials) : [],
      value_scrap_totals: checkIn.value_scrap_totals ? JSON.parse(checkIn.value_scrap_totals) : [],
      charge_materials_totals: checkIn.charge_materials_totals ? JSON.parse(checkIn.charge_materials_totals) : [],
      i_series_pcs: checkIn.i_series_pcs ? JSON.parse(checkIn.i_series_pcs) : [],
      i_series_laptops: checkIn.i_series_laptops ? JSON.parse(checkIn.i_series_laptops) : [],
    };
    
    res.json({
      success: true,
      data: parsedCheckIn
    });
  } catch (error) {
    handleError(res, error, 'Error fetching check-in');
  }
});

// POST create check-in
app.post('/api/check-ins', async (req, res) => {
  try {
    const {
      employee_name,
      total_time,
      company_id,
      company_name,
      address,
      contact_person,
      email,
      phone,
      categories,
      value_scrap,
      charge_materials,
      suspected_value_note,
      other_notes,
      started_at,
      value_scrap_totals,
      charge_materials_totals,
      has_i_series_pcs,
      has_i_series_laptops,
      i_series_pcs,
      i_series_laptops
    } = req.body;
    
    const result = await pool.request()
      .input('employee_name', sql.NVarChar, employee_name)
      .input('total_time', sql.NVarChar, total_time)
      .input('company_id', sql.UniqueIdentifier, company_id)
      .input('company_name', sql.NVarChar, company_name)
      .input('address', sql.NVarChar, address)
      .input('contact_person', sql.NVarChar, contact_person)
      .input('email', sql.NVarChar, email)
      .input('phone', sql.NVarChar, phone)
      .input('categories', sql.NVarChar(sql.MAX), JSON.stringify(categories || []))
      .input('value_scrap', sql.NVarChar(sql.MAX), JSON.stringify(value_scrap || []))
      .input('charge_materials', sql.NVarChar(sql.MAX), JSON.stringify(charge_materials || []))
      .input('suspected_value_note', sql.NVarChar(sql.MAX), suspected_value_note || '')
      .input('other_notes', sql.NVarChar(sql.MAX), other_notes || '')
      .input('started_at', sql.DateTime, started_at ? new Date(started_at) : new Date())
      .input('finished_at', sql.DateTime, new Date())
      .input('value_scrap_totals', sql.NVarChar(sql.MAX), JSON.stringify(value_scrap_totals || []))
      .input('charge_materials_totals', sql.NVarChar(sql.MAX), JSON.stringify(charge_materials_totals || []))
      .input('has_i_series_pcs', sql.Bit, has_i_series_pcs ? 1 : 0)
      .input('has_i_series_laptops', sql.Bit, has_i_series_laptops ? 1 : 0)
      .input('i_series_pcs', sql.NVarChar(sql.MAX), JSON.stringify(i_series_pcs || []))
      .input('i_series_laptops', sql.NVarChar(sql.MAX), JSON.stringify(i_series_laptops || []))
      .query(`
        INSERT INTO check_ins (
          employee_name, total_time, company_id, company_name, address,
          contact_person, email, phone, categories, value_scrap,
          charge_materials, suspected_value_note, other_notes, started_at,
          finished_at, value_scrap_totals, charge_materials_totals,
          has_i_series_pcs, has_i_series_laptops, i_series_pcs, i_series_laptops
        )
        OUTPUT INSERTED.*
        VALUES (
          @employee_name, @total_time, @company_id, @company_name, @address,
          @contact_person, @email, @phone, @categories, @value_scrap,
          @charge_materials, @suspected_value_note, @other_notes, @started_at,
          @finished_at, @value_scrap_totals, @charge_materials_totals,
          @has_i_series_pcs, @has_i_series_laptops, @i_series_pcs, @i_series_laptops
        )
      `);
    
    res.status(201).json({
      success: true,
      data: result.recordset[0],
      message: 'Check-in created successfully'
    });
  } catch (error) {
    handleError(res, error, 'Error creating check-in');
  }
});

// ============================================================================
// START SERVER
// ============================================================================

// Initialize database and start server
initDatabase().then(() => {
  app.listen(PORT, '0.0.0.0', () => {
    console.log('');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('  ğŸš€ Warehouse Check-In API Server with Authentication');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(`  âœ… Server running on: http://localhost:${PORT}`);
    console.log(`  âœ… Network access: http://<your-ip>:${PORT}`);
    console.log('  ğŸ” Authentication: SQL Server Authentication');
    console.log('');
    console.log('  Available endpoints:');
    console.log(`     GET  /health                              - Health check`);
    console.log(`     POST /api/auth/login                      - User login`);
    console.log(`     POST /api/auth/change-password            - Change password`);
    console.log(`     POST /api/auth/update-employee-preference - Update employee preference`);
    console.log(`     GET  /api/employees                       - Get all employees`);
    console.log(`     POST /api/employees                       - Create employee`);
    console.log(`     GET  /api/companies                       - Get all companies`);
    console.log(`     POST /api/companies                       - Create company`);
    console.log(`     GET  /api/categories                      - Get all categories`);
    console.log(`     POST /api/categories                      - Create category`);
    console.log(`     GET  /api/value-scrap                     - Get all value scrap`);
    console.log(`     POST /api/value-scrap                     - Create value scrap`);
    console.log(`     GET  /api/charge-materials                - Get all charge materials`);
    console.log(`     POST /api/charge-materials                - Create charge material`);
    console.log(`     GET  /api/i-series                        - Get all i-series`);
    console.log(`     POST /api/i-series                        - Create i-series`);
    console.log(`     GET  /api/check-ins                       - Get all check-ins`);
    console.log(`     POST /api/check-ins                       - Create check-in`);
    console.log('');
    console.log('  ğŸ“ To find your IP address:');
    console.log('     Windows: ipconfig');
    console.log('     Mac/Linux: ifconfig');
    console.log('');
    console.log('  ğŸ‘¤ Default Users:');
    console.log('     Dan: dan@circuitry.solutions / W1@3!-j/R');
    console.log('     Mike: mike@circuitry.solutions / W1@3!-j/R');
    console.log('');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('');
  });
}).catch(err => {
  console.error('Failed to start server:', err);
  process.exit(1);
});

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\n\nğŸ›‘ Shutting down server...');
  if (pool) {
    await pool.close();
    console.log('âœ… Database connection closed');
  }
  process.exit(0);
});
